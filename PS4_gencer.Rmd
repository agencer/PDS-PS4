---
title: "Problem Set 4"
subtitle: "Political Data Science - Spring 2020"
date: "Due May 1, 10:00 AM (Before Class)"
author: "Gencer, Alper Sukru"
output: pdf_document
number_sections: yes
header-includes:
  - \usepackage{color}
  - \usepackage{float}
editor_options: 
  chunk_output_type: console
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = T, fig.pos = 'H')
```






\section{Instructions}

\bigskip

\begin{enumerate}
  \item The following questions should each be answered within an R script. Be sure to provide many comments
in the script to facilitate grading. Undocumented code will not be graded.
  \item Work on git. Fork the repository found at https://github.com/domlockett/PDS-PS3 and add your
code, committing and pushing frequently. Use meaningful commit messages – these may affect your
grade.
  \item You may work in teams, but each student should develop their own R script. To be clear, there should
be no copy and paste. Each keystroke in the assignment should be your own.
  \item If you have any questions regarding the Problem Set, contact the TAs or use their office hours.
  \item For students new to programming, this may take a while. Get started.
  \item You will need to install ggplot2 and dplyr to complete this dataset.
\end{enumerate}






\newpage
\section{Question 1 - Sample Statistics}

\bigskip

Load the following data: http://politicaldatascience.com/PDS/Datasets/GSS-data.csv. 

\bigskip

The variable poleff11 asks participants to rate their level of agreement with the statement “People like me don’t have any say about what the government does” (see the codebook for more information on all variables in this dataset at: http://politicaldatascience.com/PDS/Datasets/gss_codebook.csv).

\bigskip

\begin{enumerate}
  \item Convert this variable into a numeric where higher values indicate higher levels of political efficacy (1- strongly agrees with the statement; 5- strongly disagrees with the statment) and all other values (‘Cant choose’ etc.) become NA’s. 
  \item What is the proportion of individuals from the entire sample who feel as though they "have a say in the government?"
  \item Using a sample of 25 from this dataset. What is the average proportion who feel as thought hey have a say?
  \item Pull a random sample of 25 from the poleff11 data and calculate the mean for this outcome. Now repeat this process 500 times and store these values in a variable called trials 25.
  \item Now create a variable called trials 100 where we do 500 trials with $n = 100$ instead of $25$.
  \item Draw a histogram of the sampling distribution for the two trials $(n=25$ vs. $n=100)$ you just conducted. Give the plots meaningful titles and axis labels. Save these plots in your repository.
  \item What notable difference occur when we use a larger sample size in our trials?
\end{enumerate}

\newpage
\section{Answer 1 - Sample Statistics}

Load the following data: http://politicaldatascience.com/PDS/Datasets/GSS-data.csv. 

\bigskip

```{r getting ready Q1, include=TRUE, warning = FALSE, message = FALSE}
rm(list = ls())
gss.data <- read.csv("http://politicaldatascience.com/PDS/Datasets/GSS-data.csv")
gss.data <- gss.data[-c(2349, 2350), ] ## included some unrelated information
```

\bigskip

\subsection{Convert this variable into a numeric where higher values indicate higher levels of political efficacy (1- strongly agrees with the statement; 5- strongly disagrees with the statment) and all other values (‘Cant choose’ etc.) become NA’s:}

```{r Q1 Part 1, include=TRUE, warning = FALSE, message = FALSE}
levels(gss.data$poleff11)
gss.data$poleff11.recoded[gss.data$poleff11 == "Strongly agree"] <- 1
gss.data$poleff11.recoded[gss.data$poleff11 == "Agree"] <- 2
gss.data$poleff11.recoded[gss.data$poleff11 == "Neither agree nor disagree"] <- 3
gss.data$poleff11.recoded[gss.data$poleff11 == "Disagree"] <- 4
gss.data$poleff11.recoded[gss.data$poleff11 == "Strongly disagree"] <- 5
gss.data$poleff11.recoded[gss.data$poleff11 == "Cant choose"] <- NA
gss.data$poleff11.recoded[gss.data$poleff11 == "Not applicable"] <- NA
gss.data$poleff11.recoded[gss.data$poleff11 == "No answer"] <- NA
```

\bigskip

\subsection{What is the proportion of individuals from the entire sample who feel as though they "have a say in the government?":}

```{r Q1 Part 2, include=TRUE, warning = FALSE, message = FALSE}

########  For this, I'll be looking at the proportion of people who "disagree (4) \ strongly disagree (5):" 

#---  including NA values:
prop_have.a.say.na <-sum(table(gss.data$poleff11.recoded)[4:5])/nrow((gss.data))
prop_have.a.say.na

#---  excluding NA values:
prop_have.a.say <-sum(table(gss.data$poleff11.recoded)[4:5])/length(na.omit(gss.data$poleff11.recoded))
prop_have.a.say

```

\bigskip

\subsection{Using a sample of 25 from this dataset. What is the average proportion who feel as thought hey have a say?:}

```{r Q1 Part 3, include=TRUE, warning = FALSE, message = FALSE}
set.seed(20200425)

#---  including NA values:
sample25_na <-sample(gss.data$poleff11.recoded, size =25)
sum(sample25_na>=4, na.rm = T)/25

#---  excluding NA values:
sample25_no.na <-sample(na.omit(gss.data$poleff11.recoded), size =25)
sum(sample25_no.na>=4, na.rm = T)/25
```


\bigskip

\subsection{Pull a random sample of 25 from the poleff11 data and calculate the mean for this outcome. Now repeat this process 500 times and store these values in a variable called \textbf{trials_25}:}

```{r Q1 Part 4, include=TRUE, warning = FALSE, message = FALSE}

########  For convenience, I will be solving by removing NA's. 

#---  Random one sample:
mean(sample(na.omit(gss.data$poleff11.recoded), size =25, replace = T))


#---  Random 500 samples:
trials_25 <- NULL
for(i in 1:500){
  trials_25 <- c(trials_25, mean(sample(na.omit(gss.data$poleff11.recoded), size =25, replace = T)))
}

```



\bigskip

\subsection{Now create a variable called trials_100 where we do 500 trials with n=100 instead of 25:}

```{r Q1 Part 5, include=TRUE, warning = FALSE, message = FALSE}

########  For convenience, I will be solving by removing NA's. 

#---  Random one sample with n = 100:
mean(sample(na.omit(gss.data$poleff11.recoded), size =100, replace = T))


#---  Random 500 samples with n = 100:
trials_100 <- NULL
for(i in 1:500){
  trials_100 <- c(trials_100, mean(sample(na.omit(gss.data$poleff11.recoded), size =100, replace = T)))
}

```



\bigskip

\subsection{Draw a histogram of the sampling distribution for the two trials (n=25 vs. n=100) you just conducted. Give the plots meaningful titles and axis labels. Save these plots in your repository.:}

```{r Q1 Part 6, include=TRUE, warning = FALSE, message = FALSE, fig.align = "center", fig.cap = "Sampling Distributions with Varying Sample Sizes"}
library(tidyverse)
##install.packages("ggpubr")
library(ggpubr)

df.trials <- as.data.frame(cbind(trials_25, trials_100))

p_trials_100 <- ggplot(df.trials) +
  geom_histogram(aes(trials_100), bins = 100, fill = "red") +
  xlab("Sample Means") +
  ggtitle("Sampling Dist. with Size 100") +
  ylim(0,50) +
  xlim(2,4) +
  theme_light()

p_trials_25 <- ggplot(df.trials) +
  geom_histogram(aes(trials_25), bins = 100, fill = "blue") +
  xlab("Sample Means") +
  ggtitle("Sampling Dist. with Size 25") +
  ylim(0,50) +
  xlim(2,4) +
  theme_light()

ggarrange(p_trials_100, p_trials_25,
                    ncol = 2, nrow = 1)

```


\bigskip

\subsection{What notable difference occur when we use a larger sample size in our trials?:}

\bigskip

As it can be seen in the graph, the spead of the sampling distribution with sample size 100 is narrower than the one with sample size 25.

```{r Q1 Part 7, include=TRUE, warning = FALSE, message = FALSE}
library(knitr)

table <- cbind(mean(na.omit(gss.data$poleff11.recoded)), mean(trials_100), 
      sd(trials_100), mean(trials_25), sd(trials_25))

colnames(table) <- c("True Mean", "Size-100 Mean", "Size-100 SD", 
                  "Size-25 Mean", "Size-25 SD")

kable(table)
```

\bigskip

Also see from the table that the mean of size-100 trials is closer to the true mean and at the same time, the sampling distribution of sample mean has less variance (smaller standard error).







\newpage
\section{Question 2 - Supervised Learning}

\bigskip

Load the following data: http://politicaldatascience.com/PDS/Datasets/SenateForecast/PollingCandidateData92-16.csv. This is is data for incumbents running for re-election to the US Senate.


```{r getting ready Q2, include=TRUE, warning = FALSE, message = FALSE}
rm(list = ls())
poll.data <- read.csv("http://politicaldatascience.com/PDS/Datasets/SenateForecast/PollingCandidateData92-16.csv")
```

\begin{itemize}
\item Poll Percentage.of.Vote.won.x is the percentage of the vote the candidate won.
\item The other variabels are mostly self-explanatory or have been used before in class.
\item However, this datset differes in that it is organized at the poll level. That is, there is one row for each poll of each senate race.
\item So there are some new variables including: the polling firm, the starting date of the poll, the “days left” until Eleciton Day, sample size, and the numberSupport (the number of respondents in that poll who indicated they supported the incumbent candidate.)
\item There is also a win variable that indicates whether the incumbent candidate won the election.
\end{itemize}



\bigskip

\subsection{Re-organize the data so it is a the election level (as opposed to the poll level):}

\bigskip

\begin{itemize}
  \item This means you will have to figure out how to reduce the polling data into a summary statistic.
  \item You might try to do this a couple of different ways based on sample size and date of the poll for use later.
\end{itemize}

```{r Q2 Part 1, include=TRUE, warning = FALSE, message = FALSE}
poll.data.2 <- poll.data %>%
  group_by(Candidateidentifier) %>%
  filter(row_number(Percentage.of.Vote.won.x) == 1) %>%
  select(-c("pollster", "poll_period", "daysLeft"))
```

\bigskip



\subsection{Randomly select 20 percent of your data to use as a “validation sample” to assess the quality of your model. You will use this division of the data in the rest of the problems below:}

\bigskip

```{r Q2 Part 2, include=TRUE, warning = FALSE, message = FALSE}

########  20 percent of data as validation (test) data:

library(rsample)

#---  See the following courses chunk below:

```

\bigskip

\subsection{Using the Poll Percentage.of.Vote.won.x variable, create at least two linear regression models to predict vote share for incumbents:}

\begin{itemize}
  \item You are free to do this any way you want, but you must assess the quality of your model using cross-validation.
  \item Train your model on your “training” data (80% of the data) and test on on the “test” data.
  \item Provide an appropriate summary statistic for your compeing models using only the validation set. (Meaning: what is your out-of-sample performance?)

\end{itemize}

\bigskip

```{r Q2 Part 3, include=TRUE, warning = FALSE, message = FALSE}


########  Linear Baseline Models:
####

rmse0 <- c()        ####  Model 0   Percentage.of.Vote.won.x ~ Democrat 
rmse1 <- c()        ####  Model 1   Percentage.of.Vote.won.x ~ Democrat + incumbent
rmse2 <- c()        ####  Model 2   Percentage.of.Vote.won.x ~ Democrat + pvi
rmse3 <- c()        ####  Model 3   Percentage.of.Vote.won.x ~ Democrat + cycle
rmse4 <- c()        ####  Model 4   Percentage.of.Vote.won.x ~ Democrat + weightexperience
rmse5 <- c()        ####  Model 4   Percentage.of.Vote.won.x ~ Democrat + state



####
####  Model 0   Percentage.of.Vote.won.x ~ Democrat 
####

for(i in 1:500){
  split_electData <- initial_split(poll.data.2, prop=.8)
  elect_train <- training(split_electData)
  elect_test <- testing(split_electData)
  model <- lm(Percentage.of.Vote.won.x ~ Democrat, data = elect_train)
  pred <- predict(model, newdata = elect_test)
  rmse0 <- c(rmse0, sqrt(mean((pred-elect_test$Percentage.of.Vote.won.x)^2)))  
}
mean(rmse0)


####
####  Model 1   Percentage.of.Vote.won.x ~ Democrat + Incumbent
####

for(i in 1:500){
  split_electData <- initial_split(poll.data.2, prop=.8)
  elect_train <- training(split_electData)
  elect_test <- testing(split_electData)
  model <- lm(Percentage.of.Vote.won.x ~ Democrat + factor(Incumbent), data = elect_train)
  pred <- predict(model, newdata = elect_test)
  rmse1 <- c(rmse1, sqrt(mean((pred-elect_test$Percentage.of.Vote.won.x)^2)))  
}


####
####  Model 2   Percentage.of.Vote.won.x ~ Democrat + pvi
####

for(i in 1:500){
  split_electData <- initial_split(poll.data.2, prop=.8)
  elect_train <- training(split_electData)
  elect_test <- testing(split_electData)
  model <- lm(Percentage.of.Vote.won.x ~ Democrat + pvi, data = elect_train)
  pred <- predict(model, newdata = elect_test)
  rmse2 <- c(rmse2, sqrt(mean((pred-elect_test$Percentage.of.Vote.won.x)^2)))  
}


####
####  Model 3   Percentage.of.Vote.won.x ~ Democrat + cycle
####

for(i in 1:500){
  split_electData <- initial_split(poll.data.2, prop=.8)
  elect_train <- training(split_electData)
  elect_test <- testing(split_electData)
  model <- lm(Percentage.of.Vote.won.x ~ Democrat + factor(cycle), data = elect_train)
  pred <- predict(model, newdata = elect_test)
  rmse3 <- c(rmse3, sqrt(mean((pred-elect_test$Percentage.of.Vote.won.x)^2)))  
}


####
####  Model 4   Percentage.of.Vote.won.x ~ Democrat + weightexperience
####

for(i in 1:500){
  split_electData <- initial_split(poll.data.2, prop=.8)
  elect_train <- training(split_electData)
  elect_test <- testing(split_electData)
  model <- lm(Percentage.of.Vote.won.x ~ Democrat + weightexperience, data = elect_train)
  pred <- predict(model, newdata = elect_test)
  rmse4 <- c(rmse4, sqrt(mean((pred-elect_test$Percentage.of.Vote.won.x)^2)))  
}


####
####  Model 5   Percentage.of.Vote.won.x ~ Democrat + state
####

for(i in 1:500){
  split_electData <- initial_split(poll.data.2, prop=.8)
  elect_train <- training(split_electData)
  elect_test <- testing(split_electData)
  model <- lm(Percentage.of.Vote.won.x ~ Democrat + factor(state), data = elect_train)
  pred <- predict(model, newdata = elect_test)
  rmse5 <- c(rmse5, sqrt(mean((pred-elect_test$Percentage.of.Vote.won.x)^2)))  
}



df.1 <- data.frame(cbind(mean(rmse0), mean(rmse1), mean(rmse2), mean(rmse3), mean(rmse4), mean(rmse5)))
colnames(df.1) <- c("Baseline (BL)", "BL + Incumbent", "BL + pvi", "BL + cycle", "BL + weightexperience", "BL + state")                 
kable(df.1)

```

\bigskip

See that the models with 1) Incumbent and 2) weightexperience are the models we are to focus on.

\bigskip

```{r Q2 Part 4, include=TRUE, warning = FALSE, message = FALSE}


########  Linear Baseline Models:
####

rmse6 <- c()        ####  Model 6   Percentage.of.Vote.won.x ~ Democrat + poly(Incumbent, 2) 
rmse7 <- c()        ####  Model 7   Percentage.of.Vote.won.x ~ Democrat * Incumbent
rmse8 <- c()        ####  Model 8   Percentage.of.Vote.won.x ~ Democrat + poly(weightexperience, 2) 
rmse9 <- c()        ####  Model 9   Percentage.of.Vote.won.x ~ Democrat * weightexperience
rmse10<- c()        ####  Model 10  Percentage.of.Vote.won.x ~ Democrat + Incumbent + weightexperience
rmse11<- c()        ####  Model 10  Percentage.of.Vote.won.x ~ Democrat + Incumbent * weightexperience




####
####  Model 6   Percentage.of.Vote.won.x ~ Democrat + poly(Incumbent, 2) 
####

for(i in 1:500){
  split_electData <- initial_split(poll.data.2, prop=.8)
  elect_train <- training(split_electData)
  elect_test <- testing(split_electData)
  model <- lm(Percentage.of.Vote.won.x ~ Democrat + poly(Incumbent, 2) , data = elect_train)
  pred <- predict(model, newdata = elect_test)
  rmse6 <- c(rmse6, sqrt(mean((pred-elect_test$Percentage.of.Vote.won.x)^2)))  
}


####
####  Model 7   Percentage.of.Vote.won.x ~ Democrat * Incumbent
####

for(i in 1:500){
  split_electData <- initial_split(poll.data.2, prop=.8)
  elect_train <- training(split_electData)
  elect_test <- testing(split_electData)
  model <- lm(Percentage.of.Vote.won.x ~ Democrat * Incumbent, data = elect_train)
  pred <- predict(model, newdata = elect_test)
  rmse7 <- c(rmse7, sqrt(mean((pred-elect_test$Percentage.of.Vote.won.x)^2)))  
}


####
####  ####  Model 8   Percentage.of.Vote.won.x ~ Democrat + poly(weightexperience, 2) 
####

for(i in 1:500){
  split_electData <- initial_split(poll.data.2, prop=.8)
  elect_train <- training(split_electData)
  elect_test <- testing(split_electData)
  model <- lm(Percentage.of.Vote.won.x ~ Democrat + poly(weightexperience, 2) , data = elect_train)
  pred <- predict(model, newdata = elect_test)
  rmse8 <- c(rmse8, sqrt(mean((pred-elect_test$Percentage.of.Vote.won.x)^2)))  
}


####
####  ####  Model 9   Percentage.of.Vote.won.x ~ Democrat * weightexperience
####

for(i in 1:500){
  split_electData <- initial_split(poll.data.2, prop=.8)
  elect_train <- training(split_electData)
  elect_test <- testing(split_electData)
  model <- lm(Percentage.of.Vote.won.x ~ Democrat * weightexperience, data = elect_train)
  pred <- predict(model, newdata = elect_test)
  rmse9 <- c(rmse9, sqrt(mean((pred-elect_test$Percentage.of.Vote.won.x)^2)))  
}


####
####  ####  Model 10  Percentage.of.Vote.won.x ~ Democrat + Incumbent + weightexperience
####

for(i in 1:500){
  split_electData <- initial_split(poll.data.2, prop=.8)
  elect_train <- training(split_electData)
  elect_test <- testing(split_electData)
  model <- lm(Percentage.of.Vote.won.x ~  Democrat + Incumbent + weightexperience, data = elect_train)
  pred <- predict(model, newdata = elect_test)
  rmse10 <- c(rmse10, sqrt(mean((pred-elect_test$Percentage.of.Vote.won.x)^2)))  
}

####
####  ####  Model 11  Percentage.of.Vote.won.x ~ Democrat + Incumbent * weightexperience
####

for(i in 1:500){
  split_electData <- initial_split(poll.data.2, prop=.8)
  elect_train <- training(split_electData)
  elect_test <- testing(split_electData)
  model <- lm(Percentage.of.Vote.won.x ~  Democrat * Incumbent * weightexperience, data = elect_train)
  pred <- predict(model, newdata = elect_test)
  rmse11 <- c(rmse11, sqrt(mean((pred-elect_test$Percentage.of.Vote.won.x)^2)))  
}

df.2 <- data.frame(cbind(mean(rmse0), mean(rmse6), mean(rmse7), mean(rmse8), mean(rmse9), 
                         mean(rmse10), mean(rmse11)))
colnames(df.2) <- c("BL", "Poly Inc", "Int. Inc.", "Poly weight",
                    "Int. weight", "BL + Inc + weight",
                    "Int. Inc and  weight")                
kable(df.2)


```

\bigskip

As it can be seen above, the smallest root mean square errors belongs to the additive model of democrat, weightexperience, and incumbency.

\newpage

\subsection{Now, using the win variable as your outcome, create at least 3 classification models. You should again assess each model on your “validation” set using appropriate methods. You must fit at least one of each:}
\begin{itemize}
  \item linear classifier,
  \item random forest model,
  \item K-nearest neighbors.
\end{itemize}

\bigskip


\bigskip


\newpage

\subsection{Now you are going to assess your classifiers using the 2018 election.:}

\begin{itemize}
  \item Most of the data you need is here: http://politicaldatascience.com/PDS/Datasets/SenateForecast/PollingCandidateData18.csv.
  \item BUT, this dataset is missing (a) the final outcome and (b) a lot of the polling data.
  \item Scrape the election results and polls from ballotpedia.org.
  \item This does not need to be perfect, but should demonstrate the basic skills covered on webscraping.
  \item Assess how each of your classifiers performs for 2018 using appropriate metrics.
\end{itemize}

\bigskip
